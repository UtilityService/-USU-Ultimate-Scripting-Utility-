local Settings = {
	
	["Prediction"] = 0;
	["ESPColor"] = Color3.fromRGB(255,255,255);
	["Manipulation"] = {
		["SlientAim"] = false;
		["Aimbot"] = false;
		["TeamCheck"] = false;
		["FOV"] = {
			["Enabled"] = false;
			["Size"] = 75;
			["Color"] = Color3.fromRGB(255, 255, 255);
			["FOV"] = nil;
		};
		["TargetPart"] = "HumanoidRootPart";
		["AutoPredict"] = false;
		["VisibleCheck"] = false;
	};
	["PingManip"] = {
		["CurrentPing"] = 0;
		["Enabled"] = false;
		["RandomPing"] = false;
	}
}


if game.CoreGui:FindFirstChild("Secret Script") then
	pcall(function()
		game.CoreGui:FindFirstChild("Secret Script"):Destroy()
	end)
end

local Aiming = false
local TargetParts = {}



local Players, ReplicatedStorage, Camera, LocalPlayer, Mouse, RunService, UserInputService = game:GetService("Players"), game:GetService("ReplicatedStorage"), workspace.Camera, game:GetService("Players").LocalPlayer, game:GetService("Players").LocalPlayer:GetMouse(), game:GetService("RunService"), game:GetService("UserInputService")
if not game:IsLoaded() then repeat task.wait() until game:IsLoaded() end
if not LocalPlayer.Character then
	repeat task.wait() until LocalPlayer.Character
end

for _,v in pairs(LocalPlayer.Character:GetChildren()) do
	if v:IsA("BasePart") then
		table.insert(TargetParts, v.Name)
	end
end

UserInputService.InputBegan:Connect(function(Input, processed)
	if processed then return end
	
	if Input.UserInputType == Enum.UserInputType.MouseButton2 then
		Aiming = true
	end
end)

UserInputService.InputEnded:Connect(function(Input, processed)
	if processed then return end

	if Input.UserInputType == Enum.UserInputType.MouseButton2 then
		Aiming = false
	end
end)

local UI = loadstring(game:HttpGet("https://raw.githubusercontent.com/cueshut/saves/main/compact"))()-- require(script:FindFirstChild("ModuleScript"))
local ESPLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/linemaster2/esp-library/main/library.lua"))();

UI = UI.init("Secret Script", "v1.0.0", "Secret Script")

Settings["Manipulation"]["FOV"]["FOV"] = Drawing.new("Circle")
Settings["Manipulation"]["FOV"]["FOV"].Transparency = 1
Settings["Manipulation"]["FOV"]["FOV"].Thickness = 1
Settings["Manipulation"]["FOV"]["FOV"].Filled = false
Settings["Manipulation"]["FOV"]["FOV"].Color = Settings["Manipulation"]["FOV"]["Color"]
Settings["Manipulation"]["FOV"]["FOV"].Visible = false

function getPredictedPos(TargetModel : Model)
	local TargetPart = TargetModel:FindFirstChild(Settings["Manipulation"]["TargetPart"])
	
	if TargetPart ~= nil then
		if Settings["Manipulation"]["AutoPredict"] then
			return TargetPart.Position + (((TargetPart.Velocity) / 4.75) * (math.random(-100,100) / 100))
		end
		return TargetPart.Position + (((TargetPart.Velocity) / 4.75) * (Settings["Prediction"]))
	end
end

function getClosestTargetToMouse()
	local target = nil
	local currentDist = math.huge
	
	local TargetPlayerTable = {}
	
	local CanKillValue = LocalPlayer:FindFirstChild("CanKill")
	
	if CanKillValue ~= nil then
		for _,v in pairs(Players:GetPlayers()) do
			if string.find(string.lower(CanKillValue.Value), v.Name:lower()) then
				table.insert(TargetPlayerTable, v)
			end
		end
	else
		TargetPlayerTable = Players:GetPlayers()
	end
	
	for _,v in pairs(TargetPlayerTable) do
		if v ~= LocalPlayer and v.Character ~= nil and v.Character:FindFirstChildOfClass("Humanoid") and v.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
			local PredictedPos = getPredictedPos(v.Character)
			
			local pos, vis = Camera:WorldToViewportPoint(PredictedPos)
			local dist = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
			
			
			
			if dist < currentDist then
				
				local function completeStatement()
					if Settings["Manipulation"]["FOV"]["Enabled"] then
						if dist <= Settings["Manipulation"]["FOV"]["Size"] then
							target = v.Character
							currentDist = dist
						end

					else
						target = v.Character
						currentDist = dist
					end
				end
				
				if Settings["Manipulation"]["VisibleCheck"] then
					if vis then
						completeStatement()
					end
				else
					completeStatement()
				end
				
			end
			
		end
	end
	
	return target
end

function updateEspColor(Color)
	ESPLibrary.BoxOutlineColor = Color
	ESPLibrary.BoxColor = Color
	ESPLibrary.NameColor = Color
	ESPLibrary.HealthOutlineColor = Color
	ESPLibrary.TracerColor = Color
	ESPLibrary.SkeletonsColor = Color
end

updateEspColor(Settings["ESPColor"])

local MainLeftSide, MainRightSide = UI:AddTab("Main", "") do
	local ManipulationSection = MainLeftSide:AddSeperator("Manipulation") do
		local SlientAim = ManipulationSection:AddToggle({
			title = "Slient Aim",
			callback = function(state)
				Settings["Manipulation"]["SlientAim"] = state
			end
		})
		
		local Aimbot = ManipulationSection:AddToggle({
			title = "Aimbot",
			callback = function(state)
				Settings["Manipulation"]["Aimbot"] = state
			end
		})
		
		local VisibleCheckManipulation = ManipulationSection:AddToggle({
			title = "Visible Check",
			callback = function(state)
				Settings["Manipulation"]["VisibleCheck"] = state
			end
		})
		
		local fovToggle, fovColor
		fovToggle, fovColor = ManipulationSection:AddToggle({
			title = "FOV | FOV Color",
			checked = Settings["Manipulation"]["FOV"]["Enabled"],
			callback = function(state)
				Settings["Manipulation"]["FOV"]["Enabled"] = state
				Settings["Manipulation"]["FOV"]["FOV"].Visible = state
			end,
			colorpicker = {
				default = Settings["Manipulation"]["FOV"]["Color"],
				callback = function(color)
					Settings["Manipulation"]["FOV"]["Color"] = color
					Settings["Manipulation"]["FOV"]["FOV"].Color = color
				end
			}
		})


		local fovSizeSlider = ManipulationSection:AddSlider({
			title = "FOV Size",
			values = {min=25,max=500,default=75},
			callback = function(set)
				Settings["Manipulation"]["FOV"]["Size"] = set
				Settings["Manipulation"]["FOV"]["FOV"].Radius = set
			end,
		})

		local TargetPartDropdown = ManipulationSection:AddDropdown({
			title = "Target Part",
			options = TargetParts,
			default = Settings["Manipulation"]["TargetPart"],
			callback = function(selected)
				Settings["Manipulation"]["TargetPart"] = TargetParts[selected]
			end
		})

	end
	
	local VisualsSection = MainLeftSide:AddSeperator("Visuals") do
		local ESP = VisualsSection:AddToggle({
			title = "ESP",
			callback = function(state)
				ESPLibrary.Enabled = state
			end,
			colorpicker = {
				default = Settings["Manipulation"]["FOV"]["Color"],
				callback = function(color)
					updateEspColor(color)
				end
			}
		})

		local NameToggle = VisualsSection:AddToggle({
			title = "Name",
			callback = function(state)
				ESPLibrary.ShowName = state
			end
		})
		
		local DistanceToggle = VisualsSection:AddToggle({
			title = "Distance",
			callback = function(state)
				ESPLibrary.ShowDistance = state
			end
		})
		
		local HealthToggle = VisualsSection:AddToggle({
			title = "Health",
			callback = function(state)
				ESPLibrary.ShowHealth  = state
			end
		})
		
		local BoxesToggle = VisualsSection:AddToggle({
			title = "Boxes",
			callback = function(state)
				ESPLibrary.ShowBox = state
			end
		})
		
		local TracersToggle = VisualsSection:AddToggle({
			title = "Tracers",
			callback = function(state)
				ESPLibrary.ShowTracer = state
			end
		})
		
		
		
	end
	
	local PredictionSection = MainRightSide:AddSeperator("Prediction") do
		
		local AutoPredict = PredictionSection:AddToggle({
			title = "Auto Predict",
			callback = function(state)
				Settings["Manipulation"]["AutoPredict"] = state
			end
		})
		
		local PredictionSlider = PredictionSection:AddSlider({
			title = "Prediction Amount",
			values = {min=0,max=100,default=0},
			callback = function(set)
				Settings["Prediction"] = 1 + (set / 100)
			end,
		})

	end
	
	local PingManipulationSection = MainRightSide:AddSeperator("Ping manipulation") do
		local PingManipToggle = PingManipulationSection:AddToggle({
			title = "Ping Manipulation",
			callback = function(state)
				Settings["PingManip"]["Enabled"] = state
			end
		})
		
		local pingSlider = PingManipulationSection:AddSlider({
			title = "Ping Slider",
			values = {min=0,max=1000000,default=Settings["PingManip"]["CurrentPing"]},
			callback = function(set)
				Settings["PingManip"]["CurrentPing"] = set
			end,
		})
		
		local HealthToggle = PingManipulationSection:AddToggle({
			title = "Randomizer",
			callback = function(state)
				Settings["PingManip"]["RandomPing"] = state
			end
		})
	end
end

RunService.RenderStepped:Connect(function()
	Settings["Manipulation"]["FOV"]["FOV"].Position = Vector2.new(Mouse.X, Mouse.Y + 36)
	if Settings["Manipulation"]["Aimbot"] and Aiming then
		local nearestTarget = getClosestTargetToMouse()
		if nearestTarget ~= nil then
			local predictedPos = getPredictedPos(nearestTarget)
			if predictedPos ~= nil then
				workspace.Camera.CFrame = CFrame.new(workspace.Camera.CFrame.Position, predictedPos)
			end
		end
		
	end
	
	if Settings["PingManip"]["Enabled"] then
		
		local Args = {[1] = Settings["PingManip"]["CurrentPing"]}
		
		if Settings["PingManip"]["RandomPing"] then
			Args[1] = math.random(0,Settings["PingManip"]["CurrentPing"])
		end

		game:GetService("ReplicatedStorage").Events.Ping:FireServer(unpack(Args))
	end
end)

local gmt = getrawmetatable(game)
setreadonly(gmt, false);
local oldNamecall = gmt.__namecall

gmt.__namecall = newcclosure(function(self, ...)
	
	if checkcaller() then
		return oldNamecall(self, ...)
	end
	
	local Args = {...}
	local method = getnamecallmethod()
	if tostring(method) == "FireServer" and Settings["Manipulation"]["SlientAim"] and tostring(self) == "RemoteEvent" then
		if Args[1] == "shoot" then
			local nearestTarget = getClosestTargetToMouse()
			if nearestTarget ~= nil then
				local predictedPos = getPredictedPos(nearestTarget)
				if predictedPos ~= nil then
					Args[2][1]["Position"] = predictedPos
					Args[2][1]["Instance"] = nearestTarget[Settings["Manipulation"]["TargetPart"]]
					Args[2][1]["Normal"] = Vector3.yAxis
					Args[2][1]["Material"] = nearestTarget[Settings["Manipulation"]["TargetPart"]].Material
					Args[2][1]["Distance"] = (Args[2][1]["From"].Position - nearestTarget[Settings["Manipulation"]["TargetPart"]].Position).Magnitude
					return self.FireServer(self, unpack(Args))
				end
			end
		end
	elseif tostring(method) == "FireServer" and tostring(self) == "MouseUpdater" then
		local nearestTarget = getClosestTargetToMouse()
		if nearestTarget ~= nil then
			local predictedPos = getPredictedPos(nearestTarget)
			if predictedPos ~= nil then
				Args[1] = predictedPos
				return self.FireServer(self, unpack(Args))
			end
		end
	elseif tostring(method) == "FireServer" and tostring(self) == "Ping" then
		if Settings["PingManip"]["Enabled"] then
			
			if Settings["PingManip"]["RandomPing"] then
				Args[1] = math.random(0,Settings["PingManip"]["CurrentPing"])
			else
				Args[1] = Settings["PingManip"]["CurrentPing"]
			end
			
			return self.FireServer(self, unpack(Args))
		end
	end
	return oldNamecall(self, ...)
end)
